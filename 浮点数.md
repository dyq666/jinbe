## 定点小数

这里讨论的小数指的是有符号的纯小数, 定点代表小数点的位置是固定的.

例如在 8 bit 中, 最高位是符号位, 其余是数值位, 小数点在符号位和数值位之间. 例如, 原码 0001 1001 的真值是 0.001 1001, 原码 1001 1001 的真值是 -0.001 1001.

### 原码表示法

原码离散范围: [1111 1111, 0111 1111], 对应真值离散范围: [-0.111 1111, 0.111 1111].

和整数相同的是, 1000 0000, 0000 0000 都代表真值 0, 因而总共有 $2^8 - 1$ 种数据.

和整数不同的是, 小数的范围是离散的, 两个小数之间有无数个小数, 而 8 bit 原码只有 $2^8 - 1$ 种数据. 因此使用有限的数存储无限的数, 就会导致精度丢失.

十进制的真值离散范围: [$-(1 - 2^{-7})$, $1 - 2^{-7}$], 由等比数列求和公式 $(a_nq - a_1) / (q -1)$ 计算得到, 0.111 1111 = ($2^{-7} * 1/2 - 2^{-1}) / (1/2 - 1)$ = $-2 * (2^{-8} - 2^{-1})$ = $1 - 2^{-7}$.

真值离散范围一般化, 假设总共有 n 位, 那么真值离散范围: [$-(1 - 2^{-n + 1})$, $1 - 2^{-n + 1}$], 总个数为 $2^n - 1$.

如 **编号 1 表格** 所示, 在位数增大时, 整数范围呈指数级增长. 小数总个数呈指数级增长, 小数范围变化比较小, . 因此在整数中数值位的大小主要影响数据的范围, 而在小数中数值位的大小主要影响数据的精度.

| (编号 1) 位数 | 有符号整数范围 (原码表示) | 有符号小数范围 (原码表示)     | 有符号小数总个数 (原码表示) |
| ------------------------ | ------------------------- | ----------------------------- | ------------------------- |
| 8                       | [-127, 127]               | [-0.9921875, 0.9921875]       | 255                       |
| 9                       | [-255, 255]               | [-0.99609375, 0.99609375]     | 511                       |
| 10                      | [-511, 511]               | [-0.998046875, 0.998046875]   | 1023                      |
| 11                      | [-1023, 1023]             | [-0.9990234375, 0.9990234375] | 2047                      |

此外, 由于在小数中范围是离散的, 且无论数值位的大小是多少, 范围都会包含 0, 因而通常会探讨离 0 最近的值是多少, 也就是分成负区间和正区间研究. 在原码中负区间和正区间是 y 轴对称的, 因此只需要研究正区间即可.

离 0 最近的正值是: 0000 0001, 即 $2^{-7}$. 由此可知正区间范围是: $[2^{-7}, 1 - 2^{-7}]$. 一般化范围则是: $[2^{-n+1}, 1 - 2^{-n+1}]$.

### 补码表示法

无论数值位的大小是多少, 模永远是 $2^0$. 实际上模由小数点的位置决定, 这里讨论的是纯小数, 小数点前没有数值位, 因此模是 $2^0$. 如果小数点前有一个数值位, 模就是 $2^1$.

补码的范围可以直接照搬整数补码的规律: 1000 0000 等于负模, 在这里等于 $-2^0$. 因此十进制的真值离散范围变成: [-1, $1 - 2^{-n + 1}$], 总个数为 $2^{n}$.

补码的范围也可以做个简单的推导, 由 **编号 1 展示** 可知, 真值离散范围是: [-1.000 0000, 0.111 1111], 十进制则是: [-1, $1 - 2^{-7}$]. 128 个补数对应 256 个真值. 和整数部分一样, 想要倒推真值, 就需要一个符号位记录补数是对应正真值还是负真值, 因此补码等于符号位 + 补数.

```
/* 编号: 1 */
  补数        真值
111 1111 - 0.111 1111, -0.000 0001
111 1110 - 0.111 1110, -0.000 0010
   ...
000 0010 - 0.000 0010, -0.111 1110
000 0001 - 0.000 0001, -0.111 1111
000 0000 - 0.000 0000, -1.000 0000
```

### 缺陷

定点数表示的范围过小, 如果有办法移动小数点的位置, 那么范围将有极大的扩展. 如 **编号 2 展示** 中所示, 第一行的真值是 $2^{-7}$, 最后一行的真值为 $2^{-1}$, 仅仅移动了小数点就让同一个段 bit (0000 0001) 表达了两个差值很大的真值. 浮点数改善了这个缺陷.

```
/* 编号: 2 */
0.000 0001
00.00 0001
000.0 0001
...
0000 00.01
0000 000.1
```

## 浮点数

### 定义

简单来说浮点数就是在定点小数的基础上, 使用了某种方式记录了小数点的位置.

那么如何记录小数点的位置呢 ? 先看一个式子: $0.01 = 0.10 * 2^{-1}$, 在这个式子中 0.01 和 0.10 实际上都是 010 , 只不过它们小数点位置不同, 而两者的位置的差距由 $2^n$ 决定, 因此我们可以在定点数的基础上, 增加一些 bit 存储指数 n.

假设在用 24 bit 存储定点小数, 8 bit 存储指数, 而且为了简易起见, 这里都先使用原码, 因此:

- 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{1111 1111}$ = $2^{-127}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0001 = $2^{-23}$.
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{0111 1111}$ = $2^{127}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$.

实际上到这里浮点数的基本概念就结束了, 这不过处于性能, 精度, 范围等多方面的考虑, 先人们定义了 IEEE 457 标准, 来规范化浮点数, 这个规范使得浮点数看起来比较复杂.

### IEEE 457

#### bit 排列

IEEE 457 规定, 底层数据排列按照, 定点小数符号位 + 指数 + 定点小数数值位.

#### 指数使用移码

为了便于比较, 规定指数是用移码, 由上面的 bit 排列可以看出, 指数使用移码后, 在定点小数符号位 + 指数的范围中直接比较. 移码采用 $2^n - 1$. 假设用 8 bit 存储, 那么移量是 127, 真值范围是 [-127, 128]. 因此上面例子中的范围的指数表示形式和范围有一定变化:

- 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{0000 0000}$ = $2^{-127}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0001 = $2^{-23}$.
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{1111 1111}$ = $2^{128}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$.

#### 规格化

规格化要求定点小数的整数部分永远为 1. 这个和我们数学中实用的科学计数法类似. 这样的好处有:

- 大家都是数值部分都是 1.xxx, 所以可以直接根据符号和指数判断出大小, 如果这两个相同才需要去比较数值部分.
- 保证你不会去使用很低精度的数, 具体原因可看下面的范围变化, 如果你想表达这些低精度的数, 你应该选用更大的存储类型.

此外, 由于大家整数部分都是 1 了, 那么这个 1 也就不用存储到计算机中了, 也就是说数值代表的真值需要 + 1 才等于实际真值, 只需要约定好即可. 因此范围:

 - 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{0000 0000}$ = $2^{-127}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0000 = 0 (真值实际上是 1.0).
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{1111 1111}$ = $2^{128}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$(真值实际上是 1 + $2^{-23}$).

#### 特殊值

标准中规定了一些极端的值用于特别的情况:

- 当指数等于最小值且定点小数部分不等于 0 时, 浮点数被识别为非规约形式.
- 当指数等于最小值且定点小数等于 0 时, 真值是 0.
- 当指数是最大值时且定点小数等于 0 时, 真值是无穷.
- 当指数是最大值时且定点小数不等于 0 时, 真值 NaN.

由上述规则可知指数的最大值和最小值都不能用在规约形式中, 因而上述的范围又变成:

- 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{0000 0001}$ = $2^{-126}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0000 = 0 (真值实际上是 1.0).
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{1111 1110}$ = $2^{127}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$(真值实际上是 1 + $2^{-23}$).

#### 单精度和双精度

|      | 符号 | 阶码 | 尾数 |
| ---- | ---- | ---- | ---- |
| 单   | 1    | 8    | 23   |
| 双   | 1    | 11   | 52   |

### C 中的浮点数

下面讨论的类型均为 float ([IEEE 754 中定义的单精度类型](https://devdocs.io/c/language/arithmetic_types#Real_floating_types)), 其他类型原理相同.

此外, 由于正负区间是 y 轴对称的, 所以下面只讨论正数.

#### 最大正规约数

最大正规约数应该满足:

- 符号为正: 0

- 阶码最大: 1111 1110 (由上述 IEEE 754 标准可知, 1111 1111 为特殊值)

- 尾数最大: 1111 1111 1111 1111 1111 111 (23 个 1)

因而编码值是: 0111 1111 0111 1111 1111 1111 1111 1111, 16 进制是: 7f 7f ff ff.

真值是: 1.1111 1111 1111 1111 1111 111 * $2^{0111 1111}$, 16 进制是: 1.fffffe * $2^{7f}$, 注意由于尾数是 23 位, 不能被 4 整除, 需要末尾补 0 后才能转换成 16 进制, 因而最后一个 16 进制数是 e.

```c
/* 编号: 1
   说明: C 中的最大正规约数. */
#include <stdio.h>
#include <float.h>
int main(void) {
    float f = FLT_MAX;

    // 这里必须经过指针将浮点数变为整数, 也就是经过 float -> float * -> int * -> int.
    // output: 0x1.fffffep+127 7f7fffff
    printf("%.6a %08x\n", f, *((int *)&f));

    // 上面的转换还有一个条件是你的机器中 int 和 float 大小必须相同.
    // 如果不同的话应该使用 char 数组, 一字节一字节的存储.
    char bytes[4];
    for (int i = 0; i < 4; i++)
        bytes[i] = *((char *)&f + i);
    // 逆序遍历的原因是, 我的机器是小端序的.
    // 在 Python 可以用简单的方式判断机器是大端序还是小端序:
    // import sys; print(sys.byteorder)  # output: little
    // output: 7f7fffff
    for (int i = 3; i > -1; i--)
        printf("%02hhx", bytes[i]);
    putchar('\n');
    return 0;
}
```

#### 最小正规约数

最小正规约数应该满足:

- 符号为正: 0

- 阶码最小: 0000 0001 (由上述 IEEE 754 标准可知, 0000 0000 为特殊值)

- 尾数最小: 0000 0000 0000 0000 0000 000 (23 个 0)

因而编码值是: 0000 0000 1000 0000 0000 0000 0000 0000, 16 进制是: 0080 0000.

真值是: 1.0000 0000 0000 0000 0000 000 * $2 ^ {1111 1110}$, 16 进制是: 1.000000 * $2^{fe}$.

```c
/* 编号: 2
   说明: C 中的最小正规约数. */
#include <stdio.h>
#include <float.h>
int main(void) {
    float f = FLT_MIN;
    // output: 0x1.000000p-126 00800000
    printf("%.6a %08x\n", f, *((int *)&f));
    return 0;
}
```

#### 最小正非规约数

最小非规约数应该满足:

- 符号: 0
- 阶码: 0000 0000 (由上述 IEEE 754 可知, 最小阶码表示非规约数, 同时真值为实际真值 + 1)
- 尾数: 0000 0000 0000 0000 0000 001

可得编码值是: 0000 0000 0000 0000 0000 0000 0000 0001, 16 进制是: 0000 0001.

真值是: $0.0000 0000 0000 0000 0000 001 * 2^{11111110} = 2^{-23} * 2^{-126} = 2^{-149}$.

```c
/* 编号: 3
   说明: C 中的最小正非规约数. */
#include <stdio.h>
#include <float.h>
int main(void) {
    float f = FLT_TRUE_MIN;
    // output: 0x1.000000p-149 00000001
    printf("%.6a %08x\n", f, *((int *)&f));
    return 0;
}
```
