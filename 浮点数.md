## 什么是浮点数

简单来说, 浮点数就是在定点数的基础上, 牺牲了一些 bit 来记录小数点的位置, 代替了定点数中约定小数点位置的方式.

### 如何记录小数点的位置

假设有一个 6 bit 无符号定点数: 000100, 小数点位置约定在最左侧, 那么此时这个数的真值是: 0.0001. 现在我们想使用 000100 表达 0.0001, 0.001, 0.01. 由下面 3 个式子可知, 只要记录下 2 的指数就能使用 000100 表达这三个值, 同时, 这个指数就是小数点的位置.

- 0.0001 = 0.000100 * $2^{0}$
- 0.001 = 0.000100 * $2^{1}$
- 0.01 = 0.000100 * $2^{2}$

现在规定在一个 6 bit 数中, 前 2 bit 用无符号原码记录 2 的指数, 后 4 bit 用无符号原码记录定点数, 小数点位置约定在最左侧. 此时, 000100 的真值是: $2^{00}$ * 0.100. 因此上面三个值在这个规定中的编码值是:

- $0.0001_{编码值}$ = 00 0001
- $0.001_{编码值}$ = 01 0001
- $0.01_{编码值}$ = 10 0001

### 定点数和浮点数的差异

在 16 bit 无符号定点小数中:

- 最大值: 1 - $2^{-16}$ = 0.9999847412109375
- 最小值: 0
- 范围内数据个数: $2^{16}$ = 65536

在 16 bit 无符号定点整数中:

- 最大值: $2^{16}$ - 1 = 65535
- 最小值: 0
- 范围内数据个数: $2^{16}$ = 65536

在 16 bit 浮点数中, 规定 6 bit 用于指数, 10 bit 用于定点数, 小数点位置约定在最左侧:

- 最大指数: 111111 = 63

- 最大值: (1 - $2^{-10}$) * $2^{63}$ = 9.214364837600035e+18
- 最小值: 0
- 范围内数据个数: $2^6 * 2^{10}$ = 65536

由上述比较可知, 定点数更适合用于特定的情况. 如果只用整数, 那么定点数可以提供百分百精度. 如果只用小数, 那么定点数可以提供最多的精度和离零更近的数. 而浮点数更适用于通用的环境, 它能比较好的平衡范围和精度.

### 为什么需要 IEEE 754

在上面的例子中, 我们随意的规定了指数和定点小数的位数. 其中指数位数越多, 范围越大, 离零数更近, 但精度更低. 因此需要专业人士确定具体的位数分配. 此外, 还有诸如边界值, 规格化, 编码值使用哪种表示法等问题需要确定.

## IEEE 754

### bit 排列

IEEE 457 规定, 底层数据排列按照, 定点小数符号位 + 指数 + 定点小数数值位.

### 指数使用移码

为了便于比较, 规定指数是用移码, 由上面的 bit 排列可以看出, 指数使用移码后, 在定点小数符号位 + 指数的范围中直接比较. 移码采用 $2^n - 1$. 假设用 8 bit 存储, 那么移量是 127, 真值范围是 [-127, 128]. 因此上面例子中的范围的指数表示形式和范围有一定变化:

- 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{0000 0000}$ = $2^{-127}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0001 = $2^{-23}$.
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{1111 1111}$ = $2^{128}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$.

### 规格化

规格化要求定点小数的整数部分永远为 1. 这个和我们数学中实用的科学计数法类似. 这样的好处有:

- 大家都是数值部分都是 1.xxx, 所以可以直接根据符号和指数判断出大小, 如果这两个相同才需要去比较数值部分.
- 保证你不会去使用很低精度的数, 具体原因可看下面的范围变化, 如果你想表达这些低精度的数, 你应该选用更大的存储类型.

此外, 由于大家整数部分都是 1 了, 那么这个 1 也就不用存储到计算机中了, 也就是说数值代表的真值需要 + 1 才等于实际真值, 只需要约定好即可. 因此范围:

 - 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{0000 0000}$ = $2^{-127}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0000 = 0 (真值实际上是 1.0).
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{1111 1111}$ = $2^{128}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$(真值实际上是 1 + $2^{-23}$).

### 特殊值

标准中规定了一些极端的值用于特别的情况:

- 当指数等于最小值且定点小数部分不等于 0 时, 浮点数被识别为非规约形式.
- 当指数等于最小值且定点小数等于 0 时, 真值是 0.
- 当指数是最大值时且定点小数等于 0 时, 真值是无穷.
- 当指数是最大值时且定点小数不等于 0 时, 真值 NaN.

由上述规则可知指数的最大值和最小值都不能用在规约形式中, 因而上述的范围又变成:

- 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{0000 0001}$ = $2^{-126}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0000 = 0 (真值实际上是 1.0).
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{1111 1110}$ = $2^{127}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$(真值实际上是 1 + $2^{-23}$).

### 单精度和双精度

|      | 符号 | 阶码 | 尾数 |
| ---- | ---- | ---- | ---- |
| 单   | 1    | 8    | 23   |
| 双   | 1    | 11   | 52   |

## 在 C 中观察浮点数极值

下面讨论的类型均为 float ([IEEE 754 中的单精度类型](https://devdocs.io/c/language/arithmetic_types#Real_floating_types)), 其他类型原理相同. 由于正负区间是 y 轴对称的, 所以只讨论正数. 同时, 可以参照 [wiki - 极值情况表]([https://zh.wikipedia.org/wiki/IEEE_754#32%E4%BD%8D%E5%96%AE%E7%B2%BE%E5%BA%A6](https://zh.wikipedia.org/wiki/IEEE_754#32位單精度)).

此外, 还需要注意, 我的机子是小端序, 因此下面所有例子中都以小端序为准.

### 最大正规约数

最大正规约数应该满足:

- 符号为正: 0

- 指数最大值减一: 1111 1110

- 尾数最大: 1111 1111 1111 1111 1111 111 (23 个 1)

因而:

- 编码值: 0111 1111 0111 1111 1111 1111 1111 1111
- 16 进制编码值: 7f 7f ff ff
- 真值: 1.1111 1111 1111 1111 1111 1110 * $2^{0111 1111}$
- C 中 %a 格式: 1.ff ff fe * $2^{127}$

```c
/*
编号: x
说明: 最大正规约数.
output: hex value of var f: 0x1.fffffep+127
        byte sequence of var f: 7f 7f ff ff
*/

#include <stdio.h>
#include <float.h>

int main(void) {
    const float f = FLT_MAX;
    const unsigned char * bytes = (unsigned char *)&f;

    printf("hex value of var f: %.6a\n", f);

    printf("byte sequence of var f: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx ", bytes[i]);
    putchar('\n');

    return 0;
}
```

### 最小正规约数

最小正规约数应该满足:

- 符号为正: 0

- 指数最小值加一: 0000 0001

- 尾数最小: 0000 0000 0000 0000 0000 000 (23 个 0)

因而:

- 编码值: 0000 0000 1000 0000 0000 0000 0000 0000
- 16 进制编码值: 00 80 00 00

- 真值: 1.0000 0000 0000 0000 0000 0000 * $2 ^ {1111 1110}$
- C 中 %a 格式: 1.00 00 00 * $2^{-126}$.

```c
/*
编号: x
说明: 最小正规约数.
output: hex value of var f: 0x1.000000p-126
        byte sequence of var f: 00 80 00 00
*/

#include <stdio.h>
#include <float.h>

int main(void) {
    const float f = FLT_MIN;
    const unsigned char * bytes = (unsigned char *)&f;

    printf("hex value of var f: %.6a\n", f);

    printf("byte sequence of var f: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx ", bytes[i]);
    putchar('\n');

    return 0;
}
```

### 最大正非规约数

最大正非规约数应该满足:

- 符号为正: 0
- 指数最小: 0000 0000
- 尾数最大: 1111 1111 1111 1111 1111 111

因而:

- 编码值: 0000 0000 0111 1111 1111 1111 1111 1111
- 16 进制编码值: 00 7f ff ff
- 真值: 0.1111 1111 1111 1111 1111 1110 * $2^{1111 1110}$
- C 中 %a 格式: 在 0.fffffe * $2^{-126}$ 的基础上左移一位得到 1.fffffc * $2^{-127}$

`float.h` 并没有提供最大正非规约数, 因此需要手动构造.

```c
/*
编号: x
说明: 最大正非规约数.
output: float value of var bytes: 0x1.fffffcp-127
*/

#include <stdio.h>

int main(void) {
    const unsigned char bytes[sizeof(float)] = {0xff, 0xff, 0x7f, 0x00};
    const float f = *(float *)bytes;

    printf("float value of var bytes: %.6a\n", f);

    return 0;
}
```

### 最小正非规约数

最小非规约数应该满足:

- 符号为正: 0
- 指数最小: 0000 0000
- 尾数最小非零值: 0000 0000 0000 0000 0000 001

因而:

- 编码值: 0000 0000 0000 0000 0000 0000 0000 0001
- 16 进制编码值: 00 00 00 01
- 真值: 0.0000 0000 0000 0000 0000 001  * $2^{-126}$
- C 中 %a 格式: 上述真值的可以变为 $2^{-23} * 2^{-126} = 2^{-149} = 1 * 2^{-149}$.

```c
/*
编号: x
说明: 最小正非规约数.
output: hex value of var f: 0x1.000000p-149
        byte sequence of var f: 00 00 00 01
*/

#include <stdio.h>
#include <float.h>

int main(void) {
    const float f = FLT_TRUE_MIN;
    const unsigned char * bytes = (unsigned char *)&f;

    printf("hex value of var f: %.6a\n", f);

    printf("byte sequence of var f: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx ", bytes[i]);
    putchar('\n');

    return 0;
}
```

### 正无穷

正无穷应该满足:

- 符号为正: 0
- 阶码最大: 1111 1111
- 尾数为零: 0000 0000 0000 0000 0000 000 (23 个 0)

因而:

- 编码值: 0111 1111 1000 0000 0000 0000 0000 0000
- 16 进制编码值: 7f 80 00 00

```c
/*
编号: x
说明: 正无穷.
output: byte sequence of var f: 7f 80 00 00
*/

#include <stdio.h>
#include <math.h>

int main(void) {
    const float f = INFINITY;
    const unsigned char * bytes = (unsigned char *)&f;

    printf("byte sequence of var f: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx ", bytes[i]);
    putchar('\n');

    return 0;
}
```

### NaN

NaN 应该满足:

- 符号为正: 0
- 阶码最大: 1111 1111
- 尾数任意非零值, 这里选用 1: 0000 0000 0000 0000 0000 001 (22 个 0, 一个 1)

因而:

- 编码值: 0111 1111 1000 0000 0000 0000 0000 0001
- 16 进制编码值: 7f 80 00 01

```c
/*
编号: x
说明: NaN.
output: float value of var bytes: nan
        byte sequence of var f2: 7fc00000
*/

#include <stdio.h>
#include <math.h>

int main(void) {
    // 手动构造一种 NaN
    const unsigned char bytes[sizeof(float)] = {0x00, 0x01, 0x80, 0x7f};
    const float f = *(float *)bytes;
    printf("float value of var bytes: %.6e\n", f);

    // 标准库中的 NaN
    const float f2 = NAN;
    const unsigned char * bytes2 = (unsigned char *)&f2;
    printf("byte sequence of var f2: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx", bytes2[i]);
    putchar('\n');

    return 0;
}
```
