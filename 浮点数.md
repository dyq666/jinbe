## 定点小数

这里讨论的小数指的是有符号的纯小数, 定点代表小数点的位置是固定的.

例如在 8 bit 中, 最高位是符号位, 其余是数值位, 小数点在符号位和数值位之间. 例如, 原码 0001 1001 的真值是 0.001 1001, 原码 1001 1001 的真值是 -0.001 1001.

### 原码表示法

原码离散范围: [1111 1111, 0111 1111], 对应真值离散范围: [-0.111 1111, 0.111 1111].

和整数相同的是, 1000 0000, 0000 0000 都代表真值 0, 因而总共有 $2^8 - 1$ 种数据.

和整数不同的是, 小数的范围是离散的, 两个小数之间有无数个小数, 而 8 bit 原码只有 $2^8 - 1$ 种数据. 因此使用有限的数存储无限的数, 就会导致精度丢失.

十进制的真值离散范围: [$-(1 - 2^{-7})$, $1 - 2^{-7}$], 由等比数列求和公式 $(a_nq - a_1) / (q -1)$ 计算得到, 0.111 1111 = ($2^{-7} * 1/2 - 2^{-1}) / (1/2 - 1)$ = $-2 * (2^{-8} - 2^{-1})$ = $1 - 2^{-7}$.

真值离散范围一般化, 假设总共有 n 位, 那么真值离散范围: [$-(1 - 2^{-n + 1})$, $1 - 2^{-n + 1}$], 总个数为 $2^n - 1$.

如 **编号 1 表格** 所示, 在位数增大时, 整数范围呈指数级增长. 小数总个数呈指数级增长, 小数范围变化比较小, . 因此在整数中数值位的大小主要影响数据的范围, 而在小数中数值位的大小主要影响数据的精度.

| (编号 1) 位数 | 有符号整数范围 (原码表示) | 有符号小数范围 (原码表示)     | 有符号小数总个数 (原码表示) |
| ------------------------ | ------------------------- | ----------------------------- | ------------------------- |
| 8                       | [-127, 127]               | [-0.9921875, 0.9921875]       | 255                       |
| 9                       | [-255, 255]               | [-0.99609375, 0.99609375]     | 511                       |
| 10                      | [-511, 511]               | [-0.998046875, 0.998046875]   | 1023                      |
| 11                      | [-1023, 1023]             | [-0.9990234375, 0.9990234375] | 2047                      |

此外, 由于在小数中范围是离散的, 且无论数值位的大小是多少, 范围都会包含 0, 因而通常会探讨离 0 最近的值是多少, 也就是分成负区间和正区间研究. 在原码中负区间和正区间是 y 轴对称的, 因此只需要研究正区间即可.

离 0 最近的正值是: 0000 0001, 即 $2^{-7}$. 由此可知正区间范围是: $[2^{-7}, 1 - 2^{-7}]$. 一般化范围则是: $[2^{-n+1}, 1 - 2^{-n+1}]$.

### 补码表示法

无论数值位的大小是多少, 模永远是 $2^0$. 实际上模由小数点的位置决定, 这里讨论的是纯小数, 小数点前没有数值位, 因此模是 $2^0$. 如果小数点前有一个数值位, 模就是 $2^1$.

补码的范围可以直接照搬整数补码的规律: 1000 0000 等于负模, 在这里等于 $-2^0$. 因此十进制的真值离散范围变成: [-1, $1 - 2^{-n + 1}$], 总个数为 $2^{n}$.

补码的范围也可以做个简单的推导, 由 **编号 1 展示** 可知, 真值离散范围是: [-1.000 0000, 0.111 1111], 十进制则是: [-1, $1 - 2^{-7}$]. 128 个补数对应 256 个真值. 和整数部分一样, 想要倒推真值, 就需要一个符号位记录补数是对应正真值还是负真值, 因此补码等于符号位 + 补数.

```
/* 编号: 1 */
  补数        真值
111 1111 - 0.111 1111, -0.000 0001
111 1110 - 0.111 1110, -0.000 0010
   ...
000 0010 - 0.000 0010, -0.111 1110
000 0001 - 0.000 0001, -0.111 1111
000 0000 - 0.000 0000, -1.000 0000
```

### 缺陷

定点数表示的范围过小, 如果有办法移动小数点的位置, 那么范围将有极大的扩展. 如 **编号 2 展示** 中所示, 第一行的真值是 $2^{-7}$, 最后一行的真值为 $2^{-1}$, 仅仅移动了小数点就让同一个段 bit (0000 0001) 表达了两个差值很大的真值. 浮点数改善了这个缺陷.

```
/* 编号: 2 */
0.000 0001
00.00 0001
000.0 0001
...
0000 00.01
0000 000.1
```

## 浮点数

### 定义

简单来说浮点数就是在定点小数的基础上, 使用了某种方式记录了小数点的位置.

那么如何记录小数点的位置呢 ? 先看一个式子: $0.01 = 0.10 * 2^{-1}$, 在这个式子中 0.01 和 0.10 实际上都是 010 , 只不过它们小数点位置不同, 而两者的位置的差距由 $2^n$ 决定, 因此我们可以在定点数的基础上, 增加一些 bit 存储指数 n.

假设在用 24 bit 存储定点小数, 8 bit 存储指数, 而且为了简易起见, 这里都先使用原码, 因此:

- 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{1111 1111}$ = $2^{-127}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0001 = $2^{-23}$.
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{0111 1111}$ = $2^{127}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$.

实际上到这里浮点数的基本概念就结束了, 这不过处于性能, 精度, 范围等多方面的考虑, 先人们定义了 IEEE 457 标准, 来规范化浮点数, 这个规范使得浮点数看起来比较复杂.

### IEEE 457

#### bit 排列

IEEE 457 规定, 底层数据排列按照, 定点小数符号位 + 指数 + 定点小数数值位.

#### 指数使用移码

为了便于比较, 规定指数是用移码, 由上面的 bit 排列可以看出, 指数使用移码后, 在定点小数符号位 + 指数的范围中直接比较. 移码采用 $2^n - 1$. 假设用 8 bit 存储, 那么移量是 127, 真值范围是 [-127, 128]. 因此上面例子中的范围的指数表示形式和范围有一定变化:

- 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{0000 0000}$ = $2^{-127}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0001 = $2^{-23}$.
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{1111 1111}$ = $2^{128}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$.

#### 规格化

规格化要求定点小数的整数部分永远为 1. 这个和我们数学中实用的科学计数法类似. 这样的好处有:

- 大家都是数值部分都是 1.xxx, 所以可以直接根据符号和指数判断出大小, 如果这两个相同才需要去比较数值部分.
- 保证你不会去使用很低精度的数, 具体原因可看下面的范围变化, 如果你想表达这些低精度的数, 你应该选用更大的存储类型.

此外, 由于大家整数部分都是 1 了, 那么这个 1 也就不用存储到计算机中了, 也就是说数值代表的真值需要 + 1 才等于实际真值, 只需要约定好即可. 因此范围:

 - 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{0000 0000}$ = $2^{-127}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0000 = 0 (真值实际上是 1.0).
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{1111 1111}$ = $2^{128}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$(真值实际上是 1 + $2^{-23}$).

#### 特殊值

标准中规定了一些极端的值用于特别的情况:

- 当指数等于最小值且定点小数部分不等于 0 时, 浮点数被识别为非规约形式.
- 当指数等于最小值且定点小数等于 0 时, 真值是 0.
- 当指数是最大值时且定点小数等于 0 时, 真值是无穷.
- 当指数是最大值时且定点小数不等于 0 时, 真值 NaN.

由上述规则可知指数的最大值和最小值都不能用在规约形式中, 因而上述的范围又变成:

- 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{0000 0001}$ = $2^{-126}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0000 = 0 (真值实际上是 1.0).
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{1111 1110}$ = $2^{127}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$(真值实际上是 1 + $2^{-23}$).

#### 单精度和双精度

|      | 符号 | 阶码 | 尾数 |
| ---- | ---- | ---- | ---- |
| 单   | 1    | 8    | 23   |
| 双   | 1    | 11   | 52   |

### 在 C 中观察浮点数极值

下面讨论的类型均为 float ([IEEE 754 中的单精度类型](https://devdocs.io/c/language/arithmetic_types#Real_floating_types)), 其他类型原理相同. 由于正负区间是 y 轴对称的, 所以只讨论正数. 同时, 可以参照 [wiki - 极值情况表]([https://zh.wikipedia.org/wiki/IEEE_754#32%E4%BD%8D%E5%96%AE%E7%B2%BE%E5%BA%A6](https://zh.wikipedia.org/wiki/IEEE_754#32位單精度)).

此外, 还需要注意, 我的机子是小端序, 因此下面所有例子中都以小端序为准.

#### 最大正规约数

最大正规约数应该满足:

- 符号为正: 0

- 指数最大值减一: 1111 1110

- 尾数最大: 1111 1111 1111 1111 1111 111 (23 个 1)

因而:

- 编码值: 0111 1111 0111 1111 1111 1111 1111 1111
- 16 进制编码值: 7f 7f ff ff
- 真值: 1.1111 1111 1111 1111 1111 1110 * $2^{0111 1111}$
- C 中 %a 格式: 1.ff ff fe * $2^{127}$

```c
/*
编号: x
说明: 最大正规约数.
output: hex value of var f: 0x1.fffffep+127
        byte sequence of var f: 7f 7f ff ff
*/

#include <stdio.h>
#include <float.h>

int main(void) {
    const float f = FLT_MAX;
    const unsigned char * bytes = (unsigned char *)&f;

    printf("hex value of var f: %.6a\n", f);

    printf("byte sequence of var f: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx ", bytes[i]);
    putchar('\n');

    return 0;
}
```

#### 最小正规约数

最小正规约数应该满足:

- 符号为正: 0

- 指数最小值加一: 0000 0001

- 尾数最小: 0000 0000 0000 0000 0000 000 (23 个 0)

因而:

- 编码值: 0000 0000 1000 0000 0000 0000 0000 0000
- 16 进制编码值: 00 80 00 00

- 真值: 1.0000 0000 0000 0000 0000 0000 * $2 ^ {1111 1110}$
- C 中 %a 格式: 1.00 00 00 * $2^{-126}$.

```c
/*
编号: x
说明: 最小正规约数.
output: hex value of var f: 0x1.000000p-126
        byte sequence of var f: 00 80 00 00
*/

#include <stdio.h>
#include <float.h>

int main(void) {
    const float f = FLT_MIN;
    const unsigned char * bytes = (unsigned char *)&f;

    printf("hex value of var f: %.6a\n", f);

    printf("byte sequence of var f: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx ", bytes[i]);
    putchar('\n');

    return 0;
}
```

#### 最大正非规约数

最大正非规约数应该满足:

- 符号为正: 0
- 指数最小: 0000 0000
- 尾数最大: 1111 1111 1111 1111 1111 111

因而:

- 编码值: 0000 0000 0111 1111 1111 1111 1111 1111
- 16 进制编码值: 00 7f ff ff
- 真值: 0.1111 1111 1111 1111 1111 1110 * $2^{1111 1110}$
- C 中 %a 格式: 在 0.fffffe * $2^{-126}$ 的基础上左移一位得到 1.fffffc * $2^{-127}$

`float.h` 并没有提供最大正非规约数, 因此需要手动构造.

```c
/*
编号: x
说明: 最大正非规约数.
output: float value of var bytes: 0x1.fffffcp-127
*/

#include <stdio.h>

int main(void) {
    const unsigned char bytes[sizeof(float)] = {0xff, 0xff, 0x7f, 0x00};
    const float f = *(float *)bytes;

    printf("float value of var bytes: %.6a\n", f);

    return 0;
}
```

#### 最小正非规约数

最小非规约数应该满足:

- 符号为正: 0
- 指数最小: 0000 0000
- 尾数最小非零值: 0000 0000 0000 0000 0000 001

因而:

- 编码值: 0000 0000 0000 0000 0000 0000 0000 0001
- 16 进制编码值: 00 00 00 01
- 真值: 0.0000 0000 0000 0000 0000 001  * $2^{-126}$
- C 中 %a 格式: 上述真值的可以变为 $2^{-23} * 2^{-126} = 2^{-149} = 1 * 2^{-149}$.

```c
/*
编号: x
说明: 最小正非规约数.
output: hex value of var f: 0x1.000000p-149
        byte sequence of var f: 00 00 00 01
*/

#include <stdio.h>
#include <float.h>

int main(void) {
    const float f = FLT_TRUE_MIN;
    const unsigned char * bytes = (unsigned char *)&f;

    printf("hex value of var f: %.6a\n", f);

    printf("byte sequence of var f: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx ", bytes[i]);
    putchar('\n');

    return 0;
}
```

#### 正无穷

正无穷应该满足:

- 符号为正: 0
- 阶码最大: 1111 1111
- 尾数为零: 0000 0000 0000 0000 0000 000 (23 个 0)

因而:

- 编码值: 0111 1111 1000 0000 0000 0000 0000 0000
- 16 进制编码值: 7f 80 00 00

```c
/*
编号: x
说明: 正无穷.
output: byte sequence of var f: 7f 80 00 00
*/

#include <stdio.h>
#include <math.h>

int main(void) {
    const float f = INFINITY;
    const unsigned char * bytes = (unsigned char *)&f;

    printf("byte sequence of var f: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx ", bytes[i]);
    putchar('\n');

    return 0;
}
```

#### NaN

NaN 应该满足:

- 符号为正: 0
- 阶码最大: 1111 1111
- 尾数任意非零值, 这里选用 1: 0000 0000 0000 0000 0000 001 (22 个 0, 一个 1)

因而:

- 编码值: 0111 1111 1000 0000 0000 0000 0000 0001
- 16 进制编码值: 7f 80 00 01

```c
/*
编号: x
说明: NaN.
output: float value of var bytes: nan
        byte sequence of var f2: 7fc00000
*/

#include <stdio.h>
#include <math.h>

int main(void) {
    // 手动构造一种 NaN
    const unsigned char bytes[sizeof(float)] = {0x00, 0x01, 0x80, 0x7f};
    const float f = *(float *)bytes;
    printf("float value of var bytes: %.6e\n", f);

    // 标准库中的 NaN
    const float f2 = NAN;
    const unsigned char * bytes2 = (unsigned char *)&f2;
    printf("byte sequence of var f2: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx", bytes2[i]);
    putchar('\n');

    return 0;
}
```
