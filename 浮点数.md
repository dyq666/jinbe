## 浮点数

### 定义

简单来说浮点数就是在定点小数的基础上, 使用了某种方式记录了小数点的位置.

那么如何记录小数点的位置呢 ? 先看一个式子: $0.01 = 0.10 * 2^{-1}$, 在这个式子中 0.01 和 0.10 实际上都是 010 , 只不过它们小数点位置不同, 而两者的位置的差距由 $2^n$ 决定, 因此我们可以在定点数的基础上, 增加一些 bit 存储指数 n.

假设在用 24 bit 存储定点小数, 8 bit 存储指数, 而且为了简易起见, 这里都先使用原码, 因此:

- 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{1111 1111}$ = $2^{-127}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0001 = $2^{-23}$.
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{0111 1111}$ = $2^{127}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$.

实际上到这里浮点数的基本概念就结束了, 这不过处于性能, 精度, 范围等多方面的考虑, 先人们定义了 IEEE 457 标准, 来规范化浮点数, 这个规范使得浮点数看起来比较复杂.

### IEEE 457

#### bit 排列

IEEE 457 规定, 底层数据排列按照, 定点小数符号位 + 指数 + 定点小数数值位.

#### 指数使用移码

为了便于比较, 规定指数是用移码, 由上面的 bit 排列可以看出, 指数使用移码后, 在定点小数符号位 + 指数的范围中直接比较. 移码采用 $2^n - 1$. 假设用 8 bit 存储, 那么移量是 127, 真值范围是 [-127, 128]. 因此上面例子中的范围的指数表示形式和范围有一定变化:

- 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{0000 0000}$ = $2^{-127}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0001 = $2^{-23}$.
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{1111 1111}$ = $2^{128}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$.

#### 规格化

规格化要求定点小数的整数部分永远为 1. 这个和我们数学中实用的科学计数法类似. 这样的好处有:

- 大家都是数值部分都是 1.xxx, 所以可以直接根据符号和指数判断出大小, 如果这两个相同才需要去比较数值部分.
- 保证你不会去使用很低精度的数, 具体原因可看下面的范围变化, 如果你想表达这些低精度的数, 你应该选用更大的存储类型.

此外, 由于大家整数部分都是 1 了, 那么这个 1 也就不用存储到计算机中了, 也就是说数值代表的真值需要 + 1 才等于实际真值, 只需要约定好即可. 因此范围:

 - 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{0000 0000}$ = $2^{-127}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0000 = 0 (真值实际上是 1.0).
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{1111 1111}$ = $2^{128}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$(真值实际上是 1 + $2^{-23}$).

#### 特殊值

标准中规定了一些极端的值用于特别的情况:

- 当指数等于最小值且定点小数部分不等于 0 时, 浮点数被识别为非规约形式.
- 当指数等于最小值且定点小数等于 0 时, 真值是 0.
- 当指数是最大值时且定点小数等于 0 时, 真值是无穷.
- 当指数是最大值时且定点小数不等于 0 时, 真值 NaN.

由上述规则可知指数的最大值和最小值都不能用在规约形式中, 因而上述的范围又变成:

- 最小正值 = 指数最小值 * 最小定点正小数. 指数最小值 = $2^{0000 0001}$ = $2^{-126}$, 最小定点正小数 = 0000 0000 0000 0000 0000 0000 = 0 (真值实际上是 1.0).
- 最大正值 = 指数最大值 * 最大定点正小数. 指数最大值 = $2^{1111 1110}$ = $2^{127}$, 最大定点正小数 = 0111 1111 1111 1111 1111 1111 = $1 - 2^{-23}$(真值实际上是 1 + $2^{-23}$).

#### 单精度和双精度

|      | 符号 | 阶码 | 尾数 |
| ---- | ---- | ---- | ---- |
| 单   | 1    | 8    | 23   |
| 双   | 1    | 11   | 52   |

### 在 C 中观察浮点数极值

下面讨论的类型均为 float ([IEEE 754 中的单精度类型](https://devdocs.io/c/language/arithmetic_types#Real_floating_types)), 其他类型原理相同. 由于正负区间是 y 轴对称的, 所以只讨论正数. 同时, 可以参照 [wiki - 极值情况表]([https://zh.wikipedia.org/wiki/IEEE_754#32%E4%BD%8D%E5%96%AE%E7%B2%BE%E5%BA%A6](https://zh.wikipedia.org/wiki/IEEE_754#32位單精度)).

此外, 还需要注意, 我的机子是小端序, 因此下面所有例子中都以小端序为准.

#### 最大正规约数

最大正规约数应该满足:

- 符号为正: 0

- 指数最大值减一: 1111 1110

- 尾数最大: 1111 1111 1111 1111 1111 111 (23 个 1)

因而:

- 编码值: 0111 1111 0111 1111 1111 1111 1111 1111
- 16 进制编码值: 7f 7f ff ff
- 真值: 1.1111 1111 1111 1111 1111 1110 * $2^{0111 1111}$
- C 中 %a 格式: 1.ff ff fe * $2^{127}$

```c
/*
编号: x
说明: 最大正规约数.
output: hex value of var f: 0x1.fffffep+127
        byte sequence of var f: 7f 7f ff ff
*/

#include <stdio.h>
#include <float.h>

int main(void) {
    const float f = FLT_MAX;
    const unsigned char * bytes = (unsigned char *)&f;

    printf("hex value of var f: %.6a\n", f);

    printf("byte sequence of var f: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx ", bytes[i]);
    putchar('\n');

    return 0;
}
```

#### 最小正规约数

最小正规约数应该满足:

- 符号为正: 0

- 指数最小值加一: 0000 0001

- 尾数最小: 0000 0000 0000 0000 0000 000 (23 个 0)

因而:

- 编码值: 0000 0000 1000 0000 0000 0000 0000 0000
- 16 进制编码值: 00 80 00 00

- 真值: 1.0000 0000 0000 0000 0000 0000 * $2 ^ {1111 1110}$
- C 中 %a 格式: 1.00 00 00 * $2^{-126}$.

```c
/*
编号: x
说明: 最小正规约数.
output: hex value of var f: 0x1.000000p-126
        byte sequence of var f: 00 80 00 00
*/

#include <stdio.h>
#include <float.h>

int main(void) {
    const float f = FLT_MIN;
    const unsigned char * bytes = (unsigned char *)&f;

    printf("hex value of var f: %.6a\n", f);

    printf("byte sequence of var f: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx ", bytes[i]);
    putchar('\n');

    return 0;
}
```

#### 最大正非规约数

最大正非规约数应该满足:

- 符号为正: 0
- 指数最小: 0000 0000
- 尾数最大: 1111 1111 1111 1111 1111 111

因而:

- 编码值: 0000 0000 0111 1111 1111 1111 1111 1111
- 16 进制编码值: 00 7f ff ff
- 真值: 0.1111 1111 1111 1111 1111 1110 * $2^{1111 1110}$
- C 中 %a 格式: 在 0.fffffe * $2^{-126}$ 的基础上左移一位得到 1.fffffc * $2^{-127}$

`float.h` 并没有提供最大正非规约数, 因此需要手动构造.

```c
/*
编号: x
说明: 最大正非规约数.
output: float value of var bytes: 0x1.fffffcp-127
*/

#include <stdio.h>

int main(void) {
    const unsigned char bytes[sizeof(float)] = {0xff, 0xff, 0x7f, 0x00};
    const float f = *(float *)bytes;

    printf("float value of var bytes: %.6a\n", f);

    return 0;
}
```

#### 最小正非规约数

最小非规约数应该满足:

- 符号为正: 0
- 指数最小: 0000 0000
- 尾数最小非零值: 0000 0000 0000 0000 0000 001

因而:

- 编码值: 0000 0000 0000 0000 0000 0000 0000 0001
- 16 进制编码值: 00 00 00 01
- 真值: 0.0000 0000 0000 0000 0000 001  * $2^{-126}$
- C 中 %a 格式: 上述真值的可以变为 $2^{-23} * 2^{-126} = 2^{-149} = 1 * 2^{-149}$.

```c
/*
编号: x
说明: 最小正非规约数.
output: hex value of var f: 0x1.000000p-149
        byte sequence of var f: 00 00 00 01
*/

#include <stdio.h>
#include <float.h>

int main(void) {
    const float f = FLT_TRUE_MIN;
    const unsigned char * bytes = (unsigned char *)&f;

    printf("hex value of var f: %.6a\n", f);

    printf("byte sequence of var f: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx ", bytes[i]);
    putchar('\n');

    return 0;
}
```

#### 正无穷

正无穷应该满足:

- 符号为正: 0
- 阶码最大: 1111 1111
- 尾数为零: 0000 0000 0000 0000 0000 000 (23 个 0)

因而:

- 编码值: 0111 1111 1000 0000 0000 0000 0000 0000
- 16 进制编码值: 7f 80 00 00

```c
/*
编号: x
说明: 正无穷.
output: byte sequence of var f: 7f 80 00 00
*/

#include <stdio.h>
#include <math.h>

int main(void) {
    const float f = INFINITY;
    const unsigned char * bytes = (unsigned char *)&f;

    printf("byte sequence of var f: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx ", bytes[i]);
    putchar('\n');

    return 0;
}
```

#### NaN

NaN 应该满足:

- 符号为正: 0
- 阶码最大: 1111 1111
- 尾数任意非零值, 这里选用 1: 0000 0000 0000 0000 0000 001 (22 个 0, 一个 1)

因而:

- 编码值: 0111 1111 1000 0000 0000 0000 0000 0001
- 16 进制编码值: 7f 80 00 01

```c
/*
编号: x
说明: NaN.
output: float value of var bytes: nan
        byte sequence of var f2: 7fc00000
*/

#include <stdio.h>
#include <math.h>

int main(void) {
    // 手动构造一种 NaN
    const unsigned char bytes[sizeof(float)] = {0x00, 0x01, 0x80, 0x7f};
    const float f = *(float *)bytes;
    printf("float value of var bytes: %.6e\n", f);

    // 标准库中的 NaN
    const float f2 = NAN;
    const unsigned char * bytes2 = (unsigned char *)&f2;
    printf("byte sequence of var f2: ");
    for (int i = sizeof(float) - 1; i > -1; i--)
        printf("%02hhx", bytes2[i]);
    putchar('\n');

    return 0;
}
```
