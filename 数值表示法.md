## 整数

### 原码表示法

在原码表示法中, 最高位是符号位, 其余位是数值位. 假设用 8 bit 存储整数, 那么原码 0000 0001 的真值是 1, 而原码 1000 0001 的真值是 -1, 由此可看出原码和真值间的转换非常简单.

原码表示法的范围. 假设用 8 bit 存储整数, 非负数的范围是 [0000 0000, 0111 1111], 即 [0, 127]. 非正数的范围是 [1111 1111, 1000 0000], 即 [-127, 0]. 由于 0000 0000 和 1000 0000 都表示 0, 导致 2^8 (256) 种组合只表示了 255 种数据, 即 [-127, 127].

使用原码作加减法时, 需要分别为加减法设计单独的逻辑. 因此, 牛逼的先人设计出了补码将加减法统一为加法.

### 补码表示法

介绍补码前先介绍一个补数的概念: 补数就是在模运算中和某个数等价的正数. 例如在 mod12 中, -3 和 +9 是等价的, (6 - 3) % 12 == (6 + 9) % 12 == 3. 就像在时钟里逆时针拨 3 小时和正时针拨 9 小时结果是一样的. 由于 12 = |-3| + |9|, 因而可得: 模 = |负数| + 补数. 而正数的补数就是它本身, 这也满足补数的概念, 因为在模运算中正数本身就是和自己等价的正数.

在计算机中整数被存储在固定的位数中, 因此也是一个模运算的环境. 假设用 7 bit 存储整数, 那么就是一个 mod128 (2^7) 的环境, 则 -15 (-000 1111) 的补数是 128 - |-15| = 113 (+111 0001), 而 +111 0001 的补数也是 +111 0001. 也就是说一个补数 (注意补数永远是正数)对应两个真值 (一正一负). 从**编号 1 展示** 中可以看出, [0, 127] 的补数对应 [127, -128] 的真值.

```
/* 编号: 1 */
补数     真值
127 - 127, -1
126 - 126, -2
   ...
  2 -   2, -126
  1 -   1, -127
  0 -   0, -128
```

目前已经可以根据真值计算出补数, 那么现在就要解决根据补数倒推真值的问题. 由于一个补数对应两个真值, 因而需要一个符号位, 标记补数是正真值的还是负真值的. 符号位 + 补数就是补码. 因而在 8 bit 存储整数的环境中, 最高位用于存储符号, 其余 7 bit 存储补数. 例如 1000 0000 就是补数 0 对应的负真值 -128, 而 0000 0000 就是补数 0 对应的正真值 0.

在 C 中可以用 unsigned 描述符来观察 signed 类型底层存储的补码.

```c
/* 编号: 1 */
#include <stdio.h>
#include <limits.h>
int main(void) {
    signed char h1 = 126, h2 = -2;
    // 126 == 7e == 0111 1101
    // -2  == fe == 1111 1101
    printf("%hhx %hhx\n", h1, h2);  // output: 7e fe

    printf("bits of int: %zd\n", sizeof(int));
    // 0111 1111 1111 1111 1111 1111 1111 1111
    printf("max of int: %x\n", INT_MAX);  // output: 7fff ffff
    // 1000 0000 0000 0000 0000 0000 0000 0000
    printf("min of int: %x\n", INT_MIN);  // output: 8000 0000
    return 0;
}
```

不幸的是, 按照上述规则, 没有比较简单的理论解释为什么符号位也能参与加法运算. 只能分不同情况证明符号位是能参与运算的, 首先必须明确参与加法运算的操作数和操作结果都必须在有效范围内, **编号 2 展示** 中选用 8 bit 存储整数, 那么真值范围就是 [-128, 127]. 范围外的溢出不进行讨论, 实际上在 C 中使用整数类型也是不应该溢出范围的.

```
/* 编号: 2 */

先说明, 在 1 + 1 = 2 中, 两个 1 代表操作数, 2 代表操作结果. 下面的术语和此处保持一致

情景: 正数 + 正数. 符号位是 0 + 0, 不变. 因此想要保证正数 + 正数 = 正数, 那么数值位 (也就是补数) 之和不能进位 (也就是 <= 127). 在 8 bit 中真值的最大正值为 127, 因此操作结果的最大值为 127, 也就是两个操作数的数值位之和必须 <= 127, 如果你选用的两个正数之和 >= 128, 那么证明你正在进行溢出加法, 溢出不在这里的讨论范围中. 一个例子如下:

 0000 0001 (补数: 1, 真值: 1)
+0111 1110 (补数: 126, 真值: 126)
 0111 1111 (补数: 127, 真值: 127)

情景: 负数 + 负数. 符号位是 1 + 1, 会变为 0, 因此想要保证负数 + 负数 = 负数, 那么数值位必须进位 (也就是 >= 128). 在 8 bit 中真值的最小负值为 -128, 因此操作结果的最小值为 -128, -128 如果由两个负数相加得到, 那么两个负数对应的数值位之和就应该是 128, 由于产生了进位, 导致最终数值位之和是 0, 而这个产生的进位使符号位变为负号. 那么现在增大操作结果, 意味着操作数也要增大, 操作数增大, 那么操作数的补数也会增大, 那么操作数补数之和就会 >= 128, 必定产生进位. 例如:

 1000 0001 (补数: 1, 真值: -127)
+1111 1111 (补数: 127, 真值: -1)
 1000 0000 (补数: 0, 真值: -128)

情景: 负数 + 正数. 符号位是 1 + 0, 会变为 1. 因此如果想要负数 + 正数 = 负数, 那么数值位就不能进位, 如果想要负数 + 正数 = 正数, 那么数值位就必须进位. 先看下面的零界状况, -1 + 1 = 0. 数值位之和是 128, 因而进位 1, 最终结果是 0, 如果此时正操作数变大, 那么补数也变大, 导致数值位之和 >= 128, 肯定进位, 最终符号位是 0. 如果此时负操作数变小, 那么补数也会变小, 导致数值位之和 <= 127, 不进位, 最终符号是 1. 如果正操作数变大, 负操作数变小, 那么就看谁改变的幅度更大, 例如正操作数从 1 变为 3, 那么补数从 1 变为 3, 负操作数从 -1 变为 -2, 那么补数从 127 变为 126, 因而最终补数之和是 129 >= 128, 进位, 最终结果是正数.

 0000 0001 (补数: 1, 真值: 1)
+1111 1111 (补数: 127, 真值: -1)
 0000 0000 (补数: 0, 真值: 0)
```

### 移码表示法

在浮点数中需要频繁比较阶码大小, 如果阶码使用补码表示法, 那么比较两个补码的大小, 需要先判断符号位, 如果符号位不同, 那么符号位为 0 的补码更大. 如果符号位相同, 那么数值位大的, 补码更大. 如果使用原码表示法, 也需要根据符号位分不同情况比较, 那么有没有办法不分情况直接比较大小呢 ? 移码因此出现了.

移码是偏移有符号整数后的结果, 这个偏移过程使有符号整数变为无符号整数, 而无符号整数可以直接比较大小.

偏移量有两种:  $2^{n-1} - 1$ 和 $2^{n-1}$ . 例如在 8 bit 中, 偏移量可以是: $ 2^{8-1} - 1 = 127$ 和 $2^{8-1} = 128$.

移码范围和无符号整数范围相同: [0, $2^n - 1$], 减去偏移量可计算出真值范围: [$1 - 2^{n-1}$, $2^n - 2^{n-1}$] 和 [$-2^{n-1}$, $2^n - 2^{n-1} - 1$]. 例如在 8 bit 中, 真值范围是: [-127, 128] 和 [-128, 127]. 实际上这二者的区别就是 -0 (1000 0000) 是代表 128 还是 -128, 如果偏移量是 127, 由 1000 0000 (?) + 0111 1111 (127) = 1111 1111 (255), 可得 -0 等于 128. 如果偏移量是 128, 由 1000 0000 (?) + 1000 0000 (128) = 0000 0000 (0), 可得 -0 等于 -128.

因此选择哪种偏移量, 取决于你是希望多表示一个负数还是多表示一个正数. 浮点数的阶码选择了多表示一个正数.

## 定点小数

这里讨论的小数指的是有符号的纯小数, 定点代表小数点的位置是固定的 (或者说, 是由某个规则约点的). 例如使用 8 bit 存储小数, 最高位是符号位, 其余是数值位, 小数点在符号位和数值位之间. 原码 0000 0001 的真值是 0.000 0001 (这里, 真值是二进制), 原码 1000 0001 的真值是 -0.000 0001. 此外, 下面都默认都使用 8 bit 存储小数.

### 原码表示法

原码离散范围: [1111 1111, 0111 1111], 对应真值离散范围: [-0.111 1111, 0.111 1111], 和整数原码一样 1000 0000, 0000 0000 都代表真值 0, 因而总共有 $2^8 - 1$ 种数据. 和整数不同的是, 小数的范围是离散的, 两个小数之间有无数个小数, 而我们只有 255 种数据. 因此, 无数个小数以原码形式存储时, 必须被映射为 255 种之一, 这也就是精度丢失.

十进制的真值离散范围: [$-(1 - 2^{-7})$, $1 - 2^{-7}$], 由等比数列求和公式 $(a_nq - a_1) / (q -1)$ 计算得到, 0.111 1111 = ($2^{-7} * 1/2 - 2^{-1}) / (1/2 - 1)$ = $-2 * (2^{-8} - 2^{-1})$ = $1 - 2^{-7}$.

真值离散范围一般化, 假设总共有 n 个数值位, 那么真值离散范围: [$-(1 - 2^{-n})$, $1 - 2^{-n}$], 总个数为 $2^{n+1} - 1$. 和整数不同的是, 在数值位增大时, 整数范围呈指数级增长. 小数总个数呈指数级增长, 小数范围变化比较小, 如 **编号 1 表格** 所示.

| (编号 1) 数值位数 | 有符号整数范围 (原码表示) | 有符号小数范围 (原码表示)     | 有符号小数总个数 (原码表示) |
| ------------------------ | ------------------------- | ----------------------------- | ------------------------- |
| 7                        | [-127, 127]               | [-0.9921875, 0.9921875]       | 255                       |
| 8                        | [-255, 255]               | [-0.99609375, 0.99609375]     | 511                       |
| 9                        | [-511, 511]               | [-0.998046875, 0.998046875]   | 1023                      |
| 10                       | [-1023, 1023]             | [-0.9990234375, 0.9990234375] | 2047                      |

### 补码表示法

首先无论数值位多大, 模的大小永远是 $2^0$, 实际上模的大小由小数点的位置决定, 这里讨论的是纯小数, 小数点前没有数值位. 因此模是 $2^0$, 如果小数点前有一个数值位, 模就是 $2^1$.

补码的范围可以直接照搬整数的规律, 即 1000 0000 代表真值 -1 而不是 0. 因此十进制的真值离散范围: [-1, $1 - 2^{-n}$], 总个数为 $2^{n+1}$. 这里简单推导下, 由 **编号 3 展示** 可知, 真值离散范围: [-1.000 0000, 0.111 1111], 十进制则是: [-1, $1 - 2^{-7}$]. 补数个数为 128, 所以总个数 256. 由于一个补数对应两个真值, 因此需要符号位来记录是正真值还是负真值. 因此补码等于符号位 + 补数.

```
/* 编号: 3 */
  补数        真值
111 1111 - 0.111 1111, -0.000 0001
111 1110 - 0.111 1110, -0.000 0010
   ...
000 0010 - 0.000 0010, -0.111 1110
000 0001 - 0.000 0001, -0.111 1111
000 0000 - 0.000 0000, -1.000 0000
```

### 缺陷

定点数表示的范围过小, 如果有办法移动小数点的位置, 那么范围将有极大的扩展. 例如 **编号 4 展示** 中所示, 第一行的真值是 $2^{-7}$, 最后一行的真值为 $2^{-1}$, 仅仅移动了小数点就让同一个段 bit 表达了差值很大的两个真值. 浮点数就是解决了这个问题.

```
/* 编号: 4 */
0.000 0001
00.00 0001
000.0 0001
...
0000 00.01
0000 000.1
```

