## 原码表示法

在原码表示法中, 最高位是符号位, 其余位是数值位. 假设用 8 bit 存储整数, 那么原码 0000 0001 的真值是 1, 而原码 1000 0001 的真值是 -1, 由此可看出原码和真值间的转换非常简单.

原码表示法的范围. 假设用 8 bit 存储整数, 非负数的范围是 [0000 0000, 0111 1111], 即 [0, 127]. 非正数的范围是 [1111 1111, 1000 0000], 即 [-127, 0]. 由于 0000 0000 和 1000 0000 都表示 0, 导致 2^8 (256) 种组合只表示了 255 种数据, 即 [-127, 127].

使用原码作加减法时, 需要分别为加减法设计单独的逻辑. 因此, 牛逼的先人设计出了补码将加减法统一为加法.

## 补码表示法

介绍补码前先介绍一个补数的概念: 补数就是在模运算中和某个数等价的正数. 例如在 mod12 中, -3 和 +9 是等价的, (6 - 3) % 12 == (6 + 9) % 12 == 3. 就像在时钟里逆时针拨 3 小时和正时针拨 9 小时结果是一样的. 由于 12 = |-3| + |9|, 因而可得: 模 = |负数| + 补数. 而正数的补数就是它本身, 这也满足补数的概念, 因为在模运算中正数本身就是和自己等价的正数.

在计算机中整数被存储在固定的位数中, 因此也是一个模运算的环境. 假设用 7 bit 存储整数, 那么就是一个 mod128 (2^7) 的环境, 则 -15 (-000 1111) 的补数是 128 - |-15| = 113 (+111 0001), 而 +111 0001 的补数也是 +111 0001. 也就是说一个补数 (注意补数永远是正数)对应两个真值 (一正一负). 从**编号 1 展示** 中可以看出, [0, 127] 的补数对应 [127, -128] 的真值.

```
/* 编号: 1 */
补数     真值
127 - 127, -1
126 - 126, -2
   ...
  2 -   2, -126
  1 -   1, -127
  0 -   0, -128
```

目前已经可以根据真值计算出补数, 那么现在就要解决根据补数倒推真值的问题. 由于一个补数对应两个真值, 因而需要一个符号位, 标记补数是正真值的还是负真值的. 符号位 + 补数就是补码. 因而在 8 bit 存储整数的环境中, 最高位用于存储符号, 其余 7 bit 存储补数. 例如 1000 0000 就是补数 0 对应的负真值 -128, 而 0000 0000 就是补数 0 对应的正真值 0.

在 C 中可以用 unsigned 描述符来观察 signed 类型底层存储的补码.

```c
/* 编号: 1 */
#include <stdio.h>
int main(void) {
    signed char h1 = 126, h2 = -2;
    // 126 == 7e == 0111 1101
    // -2  == fe == 1111 1101
    printf("%hhx %hhx\n", h1, h2);  // output: 7e fe
    return 0;
}
```