## 原码表示法

在原码表示法中, 最高位是符号位, 其余位是数值位. 假设用 8 bit 存储整数, 那么原码 0000 0001 的真值是 1, 而原码 1000 0001 的真值是 -1, 由此可看出原码和真值间的转换非常简单.

原码表示法的范围. 假设用 8 bit 存储整数, 非负数的范围是 [0000 0000, 0111 1111], 即 [0, 127]. 非正数的范围是 [1111 1111, 1000 0000], 即 [-127, 0]. 由于 0000 0000 和 1000 0000 都表示 0, 导致 2^8 (256) 种组合只表示了 255 种数据, 即 [-127, 127].

使用原码作加减法时, 需要分别为加减法设计单独的逻辑. 因此, 牛逼的先人设计出了补码将加减法统一为加法.

## 补码表示法

介绍补码前先介绍一个补数的概念: 补数就是在模运算中和某个数等价的正数. 例如在 mod12 中, -3 和 +9 是等价的, (6 - 3) % 12 == (6 + 9) % 12 == 3. 就像在时钟里逆时针拨 3 小时和正时针拨 9 小时结果是一样的. 由于 12 = |-3| + |9|, 因而可得: 模 = |负数| + 补数. 而正数的补数就是它本身, 这也满足补数的概念, 因为在模运算中正数本身就是和自己等价的正数.

在计算机中整数被存储在固定的位数中, 因此也是一个模运算的环境. 假设用 7 bit 存储整数, 那么就是一个 mod128 (2^7) 的环境, 则 -15 (-000 1111) 的补数是 128 - |-15| = 113 (+111 0001), 而 +111 0001 的补数也是 +111 0001. 也就是说一个补数 (注意补数永远是正数)对应两个真值 (一正一负). 从**编号 1 展示** 中可以看出, [0, 127] 的补数对应 [127, -128] 的真值.

```
/* 编号: 1 */
补数     真值
127 - 127, -1
126 - 126, -2
   ...
  2 -   2, -126
  1 -   1, -127
  0 -   0, -128
```

目前已经可以根据真值计算出补数, 那么现在就要解决根据补数倒推真值的问题. 由于一个补数对应两个真值, 因而需要一个符号位, 标记补数是正真值的还是负真值的. 符号位 + 补数就是补码. 因而在 8 bit 存储整数的环境中, 最高位用于存储符号, 其余 7 bit 存储补数. 例如 1000 0000 就是补数 0 对应的负真值 -128, 而 0000 0000 就是补数 0 对应的正真值 0.

在 C 中可以用 unsigned 描述符来观察 signed 类型底层存储的补码.

```c
/* 编号: 1 */
#include <stdio.h>
#include <limits.h>
int main(void) {
    signed char h1 = 126, h2 = -2;
    // 126 == 7e == 0111 1101
    // -2  == fe == 1111 1101
    printf("%hhx %hhx\n", h1, h2);  // output: 7e fe

    printf("bits of int: %zd\n", sizeof(int));
    // 0111 1111 1111 1111 1111 1111 1111 1111
    printf("max of int: %x\n", INT_MAX);  // output: 7fff ffff
    // 1000 0000 0000 0000 0000 0000 0000 0000
    printf("min of int: %x\n", INT_MIN);  // output: 8000 0000
    return 0;
}
```

不幸的是, 按照上述规则, 没有比较简单的理论解释为什么符号位也能参与加法运算. 只能分不同情况证明符号位是能参与运算的, 首先必须明确参与加法运算的操作数和操作结果都必须在有效范围内, **编号 2 展示** 中选用 8 bit 存储整数, 那么真值范围就是 [-128, 127]. 范围外的溢出不进行讨论, 实际上在 C 中使用整数类型也是不应该溢出范围的.

```
/* 编号: 2 */

先说明, 在 1 + 1 = 2 中, 两个 1 代表操作数, 2 代表操作结果. 下面的术语和此处保持一致

情景: 正数 + 正数. 符号位是 0 + 0, 不变. 因此想要保证正数 + 正数 = 正数, 那么数值位 (也就是补数) 之和不能进位 (也就是 <= 127). 在 8 bit 中真值的最大正值为 127, 因此操作结果的最大值为 127, 也就是两个操作数的数值位之和必须 <= 127, 如果你选用的两个正数之和 >= 128, 那么证明你正在进行溢出加法, 溢出不在这里的讨论范围中. 一个例子如下:

 0000 0001 (补数: 1, 真值: 1)
+0111 1110 (补数: 126, 真值: 126)
 0111 1111 (补数: 127, 真值: 127)

情景: 负数 + 负数. 符号位是 1 + 1, 会变为 0, 因此想要保证负数 + 负数 = 负数, 那么数值位必须进位 (也就是 >= 128). 在 8 bit 中真值的最小负值为 -128, 因此操作结果的最小值为 -128, -128 如果由两个负数相加得到, 那么两个负数对应的数值位之和就应该是 128, 由于产生了进位, 导致最终数值位之和是 0, 而这个产生的进位使符号位变为负号. 那么现在增大操作结果, 意味着操作数也要增大, 操作数增大, 那么操作数的补数也会增大, 那么操作数补数之和就会 >= 128, 必定产生进位. 例如:

 1000 0001 (补数: 1, 真值: -127)
+1111 1111 (补数: 127, 真值: -1)
 1000 0000 (补数: 0, 真值: -128)

情景: 负数 + 正数. 符号位是 1 + 0, 会变为 1. 因此如果想要负数 + 正数 = 负数, 那么数值位就不能进位, 如果想要负数 + 正数 = 正数, 那么数值位就必须进位. 先看下面的零界状况, -1 + 1 = 0. 数值位之和是 128, 因而进位 1, 最终结果是 0, 如果此时正操作数变大, 那么补数也变大, 导致数值位之和 >= 128, 肯定进位, 最终符号位是 0. 如果此时负操作数变小, 那么补数也会变小, 导致数值位之和 <= 127, 不进位, 最终符号是 1. 如果正操作数变大, 负操作数变小, 那么就看谁改变的幅度更大, 例如正操作数从 1 变为 3, 那么补数从 1 变为 3, 负操作数从 -1 变为 -2, 那么补数从 127 变为 126, 因而最终补数之和是 129 >= 128, 进位, 最终结果是正数.

 0000 0001 (补数: 1, 真值: 1)
+1111 1111 (补数: 127, 真值: -1)
 0000 0000 (补数: 0, 真值: 0)
```

## 移码表示法

在浮点数中需要频繁的比较阶码的大小, 如果阶码使用补码存储, 那么比较两个补码的大小, 需要先判断符号位, 如果符号位不同, 那么符号位为 0 的补码更大. 如果符号位相同, 那么数值位大的, 补码更大. 如果使用原码存储, 也需要根据符号位分不同情况比较, 那么有没有办法不按符号位分情况, 直接比较大小呢 ? 移码应运而生.

移码将有符号整数做偏移, 使所有偏移后的值都为正数, 例如 8 bit 表示的真值范围是 [-128, 127], 那么移码就是 [0000 0000, 1111 1111], 即 [0, 255], 偏移量是 1000 000, 即 128.
