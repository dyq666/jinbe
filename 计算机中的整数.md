## 原码表示法

### 定义

原码具体规定为: 最高位是符号位, 其余位是数值位. 例如在 8 bit 中, 原码 0000 0101 的真值是 +101, 而原码 1000 0101 的真值是 -101, 由此可看出原码和真值间的转换直观又简单.

### 真值范围

在 8 bit 中:

- 非正数的范围是: [1111 1111, 1000 0000], 对应真值范围: [-127, -0].
- 非负数的范围是: [0000 0000, 0111 1111], 对应真值范围:  [0, 127].
- 总范围是: [1111 1111, 0111 1111], 对应真值范围: [-127, 127]

因而在 n bit 中, 真值范围是: $[-2^{n-1}, 2^{n-1}]$.

### 缺陷

- 由于 0000 0000 和 1000 0000 都表示真值 0, 导致 $2^8$ 种组合只表示了 $2^8 -  1$ 种数据.
- 由于符号位不能参与运算, 例如: 0000 0001 (1) + 1000 0001 (-1) = 1000 0010(-2). 因此需要硬件支持加法和减法.

### 公式

$X_原 = 2^{n-1} - X $ $(-2^{n-1} < X <= 0)$. 由于非负数公式比较容易理解, 这里就不讨论了, [wiki 中的详细公式]([https://zh.wikipedia.org/wiki/%E5%8E%9F%E7%A0%81#%E6%95%B4%E6%95%B0%E5%8E%9F%E7%A0%81%E7%9A%84%E5%AE%9A%E4%B9%89](https://zh.wikipedia.org/wiki/原码#整数原码的定义)).

首先对公式变形, 当 $X <= 0$ 时, $|X| = -X$. 因而公式可变为: $X_原 = 2^{n-1} + |X| $.

公式中 $2^{n-1} $ 就代表符号位为 1, $|X|$ 则代表数值位照抄.以 8 bit 为例, 假设 X = -101, 那么 $2^{n-1} = 2^7 = 1000 0000$, $|X| = 101$, 因而 $X_原 = 1000 0000 + 101 = 1000 0101$.

这里提到公式的原因并不是因为它有多么重要, 而是为了提供一种用二进制的视角看待十进制公式的思路.

## 补码表示法

补码的最大优点是: 硬件只需要支持加法运算, 就能完成真值的加减法运算.

下面补码的说明和常见的说明有些出入, 术语也不是特别准确, 但比较准确的说明了补码的来历, 以及基本可以自圆其说, 尤其是在 1000 0000 为什么代表 -128 的问题上.

### 补数

介绍补码前先说明补数的概念: 补数就是在模运算中和某个数等价的正数.

例如在十进制 mod12 中, -3 和 +9 是等价的, (6 - 3) % 12 == (6 + 9) % 12 == 3, 就像在时钟里逆时针拨 3 小时和正时针拨 9 小时结果是一样的. 由于 12 = |-3| + |9|, 因而可得: 模 = |负真值| + 补数.

正数的补数就是它本身, 这也满足补数的概念, 因为在模运算中正数本身就是和自己等价的正数.

在计算机中整数被存储在固定的位数中, 因此也是一个模运算的环境. 如果用 7 bit 存储整数, 那么就是一个 mod$2^7$ 的环境. 在这个环境中, -15 的补数是: 128 - |-15| = 113 (111 0001), 而 113 的补数也是 113 (111 0001). 这意味着一个补数对应两个真值 (一正一负).

从**编号 1 展示** 中可以看出, 范围 [0, 127] 的补数对应范围 [-128, 127] 的真值.

```
/* 编号: 1 */
补数     真值
127 - 127, -1
126 - 126, -2
   ...
  2 -   2, -126
  1 -   1, -127
  0 -   0, -128
```

### 补码定义

目前已经可以根据真值计算出补数, 那么现在就要解决根据补数倒推真值的问题. 由于一个补数对应两个真值, 因而需要一个标记位, 0 代表对应正真值, 1 代表对应负真值. 因此也可叫做符号位, 注意这个符号不是补数的符号, 而是对应的真值符号.

符号位 + 补数就是补码, 补码的定义为: 最高位是符号位, 其余位存储补数.

在 8 bit 中, 补码 1000 0000 就是补数 000 0000 对应的负真值 -128, 而补码 0000 0000 就是补数 000 0000 对应的正真值 0.

### 在 C 中观察补码

在 C 中可以用 unsigned 描述符来观察 signed 类型数据的补码.

```c
/* 编号: 1
   说明: 观察补码 */
#include <stdio.h>
int main(void) {
    signed char c1 = -128, c2 = 0;  // 这两个真值对应的补数都是 0
    signed char c3 = -1, c4 = 127;  // 这两个真值对应的补数都是 127
    printf("%hhx %hhx\n", c1, c2);  // output: 80 0,  这里转成 2 进制是: 1000 0000 0000 0000
    printf("%hhx %hhx\n", c3, c4);  // output: ff 7f, 这里转成 2 进制是: 1111 1111 0111 1111
    return 0;
}
```

### 符号位参与运算

不幸的是, 按照上述规则, 没有比较简单的方法解释为什么符号位也能参与加法运算. 只能分不同情况粗略证明符号位是能参与运算的.

首先需要说明:

- 在式子 1 + 1 = 2 中, 两个 1 被叫做操作数, 2 被叫做操作结果. 下面的术语和此处保持一致.
- 参与加法运算的操作数和操作结果都必须在有效范围内. 范围外的溢出不进行讨论, 实际上在 C 中使用整数类型也是不应该溢出范围的.

- 默认用 8 bit 存储整数.

#### 情况 1: 正真值 + 正真值

如果希望正真值 + 正真值的操作结果是正真值, 那么操作结果的补码形式的符号位必须是 0.

因为两个操作数的符号位之和一定是 0, 所以, 只要操作数的补数之和不进位 (也就是 <= 127). 就可以证明符号位在此情况下可以参与运算.

由于操作结果不能向上溢出, 因此操作结果的最大补数肯定是 127, 那么操作数的补数之和肯定 <= 127. 一个例子如下:

```
/* 编号: 2 */
 0000 0001 (补数: 1, 真值: 1)
+0111 1110 (补数: 126, 真值: 126)
----------
 0111 1111 (补数: 127, 真值: 127)
```

#### 情况 2: 负真值 + 负真值

如果希望负真值 + 负真值的操作结果是负真值, 那么操作结果的补码形式的符号位必须是 1.

因为两个操作数的符号位之和一定是 0, 所以, 只要操作数的补数之和进位 (也就是 >= 128). 就可以证明符号位在此情况下可以参与运算.

由于操作结果不能向下溢出, 因此操作结果的最小补数肯定是 0 (对应真值是 -128), 也就是两个操作数的最小补数之和是 128, 因此操作数的补数之和一定 >= 128, 必定产生进位. 一个例子如下:

```
/* 编号: 3 */

 1000 0001 (补数: 1, 真值: -127)
+1111 1111 (补数: 127, 真值: -1)
----------
 1000 0000 (补数: 0, 真值: -128)
```

#### 情况 3: 负真值 + 正真值

因为两个操作数的符号位之和一定是 1, 如果希望操作结果是正真值, 那么操作数的补数之和必须进位, 如果希望操作结果是负真值, 那么操作数的补数之和不能进位.

先看 **编号 4 展示** 中的零界状况, 操作数的补数之和是 128, 产生进位, 操作结果为正真值. 然后分为以下几种情况:

- 如果此时正操作数变大, 那么补数也变大, 导致补数之和 >= 128, 最终操作结果为正真值.

- 如果此时负操作数变小, 那么补数也会变小, 导致数值位之和 <= 127, 不进位, 最终操作结果为负真值.
- 如果正操作数变大, 负操作数变小, 那么就看谁改变的幅度更大, 例如正操作数从 1 变为 3, 那么补数从 1 变为 3, 负操作数从 -1 变为 -2, 那么补数从 127 变为 126, 因而最终补数之和是 129 >= 128, 进位, 最终操作结果为正真值.

以上几种情况证明了符号位在此情况下可以参与运算.

```
/* 编号: 4 */
 0000 0001 (补数: 1, 真值: 1)
+1111 1111 (补数: 127, 真值: -1)
----------
 0000 0000 (补数: 0, 真值: 0)
```

## 移码表示法

### 移码定义

在浮点数中需要频繁比较阶码大小, 如果阶码使用补码表示法, 那么比较两个补码的大小, 需要先判断符号位, 如果符号位不同, 那么符号位为 0 的补码更大. 如果符号位相同, 那么数值位大的, 补码更大. 如果使用原码表示法, 也需要根据符号位分不同情况比较, 那么有没有办法不分情况直接比较大小呢 ? 移码因此出现了.

移码是偏移有符号整数后的结果, 这个偏移过程使有符号整数变为无符号整数, 而无符号整数可以直接比较大小.

### 偏移量

偏移量有两种:  $2^{n-1} - 1$ 和 $2^{n-1}$ . 例如在 8 bit 中, 偏移量可以是: $ 2^{8-1} - 1 = 127$ 和 $2^{8-1} = 128$.

### 真值范围

移码范围和无符号整数范围相同: [0, $2^n - 1$], 减去偏移量可计算出真值范围: [$1 - 2^{n-1}$, $2^n - 2^{n-1}$] 和 [$-2^{n-1}$, $2^n - 2^{n-1} - 1$].

在 8 bit 中, 真值范围是: [-127, 128] 和 [-128, 127]. 实际上这二者的区别就是 -0 (1000 0000) 是表示 128 还是 -128, 如果偏移量是 127, 由 1000 0000 (?) + 0111 1111 (127) = 1111 1111 (255), 可得 1000 0000 的真值是 128. 如果偏移量是 128, 由 1000 0000 (?) + 1000 0000 (128) = 0000 0000 (0), 可得 1000 0000 的真值是 -128.

因此选择哪种偏移量, 取决于你希望真值范围多表示一个正数还是多表示一个负数. 浮点数的阶码选择了多表示一个正数.
